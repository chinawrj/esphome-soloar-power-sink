esphome:
  name: ac-protocol-analyzer
  friendly_name: AC Protocol Analyzer
  comment: Universal A/C IR protocol analyzer using IRremoteESP8266
  libraries:
    - "crankyoldgit/IRremoteESP8266@2.8.6"
  on_boot:
    priority: -100
    then:
      - script.execute: init_ir_receiver
      - logger.log: "ğŸš€ AC Protocol Analyzer Ready"

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino
    version: 2.0.14  # ä½¿ç”¨ä¸IRremoteESP8266å…¼å®¹çš„Arduinoç‰ˆæœ¬
    platform_version: 6.5.0

# æ—¥å¿—é…ç½®
logger:
  level: DEBUG
  hardware_uart: USB_CDC

# WiFi (disabled)
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  enable_on_boot: false

# å…¨å±€å˜é‡
globals:
  - id: irrecv_ptr
    type: void*
    initial_value: 'nullptr'
  - id: total_signals
    type: int
    initial_value: '0'

# åˆå§‹åŒ–IRremoteESP8266
script:
  - id: init_ir_receiver
    then:
      - lambda: |-
          #include <IRremoteESP8266.h>
          #include <IRrecv.h>
          #include <IRac.h>
          #include <IRutils.h>
          
          // åˆ›å»ºIRrecvå¯¹è±¡
          const uint16_t kRecvPin = 1;  // GPIO1
          const uint16_t kCaptureBufferSize = 1024;
          const uint8_t kTimeout = 50;
          const bool kUseModulation = true;
          
          IRrecv* irrecv = new IRrecv(kRecvPin, kCaptureBufferSize, kTimeout, kUseModulation);
          irrecv->enableIRIn();
          
          // ä¿å­˜æŒ‡é’ˆåˆ°å…¨å±€å˜é‡
          id(irrecv_ptr) = (void*)irrecv;
          
          ESP_LOGI("IR", "âœ… IRremoteESP8266 initialized on GPIO1");
          ESP_LOGI("IR", "ğŸ“Š Buffer: %d bytes, Timeout: %dms", kCaptureBufferSize, kTimeout);

# æŒ‰é’® - ç»Ÿè®¡å¤ä½
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO41
      mode:
        input: true
        pullup: true
      inverted: true
    name: "Reset Statistics"
    on_press:
      - lambda: |-
          id(total_signals) = 0;
          ESP_LOGI("STATS", "ğŸ“Š Statistics cleared");

# å¾ªç¯æ£€æŸ¥IRä¿¡å·
interval:
  - interval: 10ms  # å¿«é€Ÿè½®è¯¢
    then:
      - lambda: |-
          #include <IRremoteESP8266.h>
          #include <IRrecv.h>
          #include <IRac.h>
          #include <IRutils.h>
          
          IRrecv* irrecv = (IRrecv*)id(irrecv_ptr);
          if (irrecv == nullptr) return;
          
          static decode_results results;
          
          if (irrecv->decode(&results)) {
            id(total_signals)++;
            
            // è·å–åè®®åç§°
            String protocol_name = typeToString(results.decode_type);
            String hex_data = resultToHexidecimal(&results);
            
            ESP_LOGI("IR", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            ESP_LOGI("IR", "â•‘ Protocol: %-35sâ•‘", protocol_name.c_str());
            ESP_LOGI("IR", "â•‘ Data: %-39sâ•‘", hex_data.c_str());
            ESP_LOGI("IR", "â•‘ Bits: %-39dâ•‘", results.bits);
            
            // æ£€æŸ¥æ˜¯å¦ä¸ºA/Cåè®®
            if (IRAc::isProtocolSupported(results.decode_type)) {
              stdAc::state_t state;
              if (IRAc::toCommon(&results, &state, nullptr)) {
                ESP_LOGI("IR", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                ESP_LOGI("IR", "â•‘          A/C Protocol Fields                 â•‘");
                ESP_LOGI("IR", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                
                // æ˜¾ç¤ºæœ‰æ„ä¹‰çš„å­—æ®µ
                if (state.power) {
                  ESP_LOGI("IR", "â•‘ Power: ON                                    â•‘");
                }
                
                if (state.mode != stdAc::opmode_t::kOff) {
                  const char* mode_str = "Unknown";
                  switch (state.mode) {
                    case stdAc::opmode_t::kAuto: mode_str = "Auto"; break;
                    case stdAc::opmode_t::kCool: mode_str = "Cool (åˆ¶å†·)"; break;
                    case stdAc::opmode_t::kHeat: mode_str = "Heat (åˆ¶çƒ­)"; break;
                    case stdAc::opmode_t::kDry: mode_str = "Dry (é™¤æ¹¿)"; break;
                    case stdAc::opmode_t::kFan: mode_str = "Fan (é€é£)"; break;
                    default: break;
                  }
                  ESP_LOGI("IR", "â•‘ Mode: %-38sâ•‘", mode_str);
                }
                
                if (state.degrees > 0 && state.degrees < 50) {
                  ESP_LOGI("IR", "â•‘ Temp: %.1fÂ°C                                  â•‘", state.degrees);
                }
                
                if (state.fanspeed != stdAc::fanspeed_t::kAuto) {
                  const char* fan_str = "Unknown";
                  switch (state.fanspeed) {
                    case stdAc::fanspeed_t::kMin: fan_str = "Min"; break;
                    case stdAc::fanspeed_t::kLow: fan_str = "Low"; break;
                    case stdAc::fanspeed_t::kMedium: fan_str = "Medium"; break;
                    case stdAc::fanspeed_t::kHigh: fan_str = "High"; break;
                    case stdAc::fanspeed_t::kMax: fan_str = "Max"; break;
                    default: break;
                  }
                  ESP_LOGI("IR", "â•‘ Fan: %-39sâ•‘", fan_str);
                }
                
                if (state.quiet) ESP_LOGI("IR", "â•‘ Quiet: ON                                    â•‘");
                if (state.turbo) ESP_LOGI("IR", "â•‘ Turbo: ON                                    â•‘");
                if (state.econo) ESP_LOGI("IR", "â•‘ Econo: ON                                    â•‘");
              }
            } else {
              // éA/Cåè®®
              ESP_LOGI("IR", "â•‘ Non-A/C Protocol                             â•‘");
            }
            
            ESP_LOGI("IR", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
            irrecv->resume();
          }
  
  # ç»Ÿè®¡æŠ¥å‘Š
  - interval: 30s
    then:
      - lambda: |-
          ESP_LOGI("STATS", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          ESP_LOGI("STATS", "ğŸ“Š Total Signals: %d", id(total_signals));
          ESP_LOGI("STATS", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
