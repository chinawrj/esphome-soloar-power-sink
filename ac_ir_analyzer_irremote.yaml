esphome:
  name: ac-ir-analyzer
  friendly_name: AC IR Analyzer with IRremoteESP8266
  comment: Air conditioner IR protocol analyzer using IRremoteESP8266 library
  platformio_options:
    lib_deps:
      - https://github.com/crankyoldgit/IRremoteESP8266.git  # Use master branch for Arduino v3.x compatibility
    build_flags:
      - -DDECODE_AC=true
      - -DSEND_AC=true

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino
    # Use recommended version for ESPHome compatibility

# æ—¥å¿—é…ç½® - USB CDCä¸²å£è¾“å‡º
logger:
  level: DEBUG
  hardware_uart: USB_CDC
  logs:
    component: ERROR

# ç¦ç”¨WiFi - çº¯æœ¬åœ°è¿è¡Œ
wifi:
  enable_on_boot: false
  ap:
    ssid: "AC-IR-Analyzer"
    password: "irremote8266"

# å…¨å±€å˜é‡å­˜å‚¨åè®®ç»Ÿè®¡
globals:
  - id: total_signals
    type: int
    initial_value: '0'
  - id: protocol_stats
    type: std::map<std::string, int>
    restore_value: false

# Lambda-based IR monitoring with IRremoteESP8266
script:
  - id: ir_receiver_loop
    mode: queued
    then:
      - lambda: |-
          #include <IRremoteESP8266.h>
          #include <IRrecv.h>
          #include <IRac.h>
          #include <IRutils.h>
          
          static const uint16_t kRecvPin = 1;  // GPIO1
          static const uint16_t kCaptureBufferSize = 1024;
          static const uint8_t kTimeout = 50;
          
          static IRrecv *irrecv = nullptr;
          static decode_results results;
          
          // Initialize receiver once
          if (irrecv == nullptr) {
            irrecv = new IRrecv(kRecvPin, kCaptureBufferSize, kTimeout, true);
            irrecv->enableIRIn();
            ESP_LOGI("IR-ANALYZER", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            ESP_LOGI("IR-ANALYZER", "ğŸš€ IRremoteESP8266 AC Protocol Analyzer Started");
            ESP_LOGI("IR-ANALYZER", "ğŸ“¡ IR RX: GPIO1 | Supporting 50+ AC Protocols");
            ESP_LOGI("IR-ANALYZER", "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          }
          
          // Check for IR data
          if (irrecv->decode(&results)) {
            id(total_signals)++;
            
            // è·å–åè®®åç§°
            String protocol = typeToString(results.decode_type);
            
            // æ›´æ–°ç»Ÿè®¡
            std::string proto_str = protocol.c_str();
            if (id(protocol_stats).find(proto_str) == id(protocol_stats).end()) {
              id(protocol_stats)[proto_str] = 1;
            } else {
              id(protocol_stats)[proto_str]++;
            }
            
            // è¾“å‡ºåŸºç¡€ä¿¡æ¯
            ESP_LOGI("IR-DECODER", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            ESP_LOGI("IR-DECODER", "â•‘  Protocol: %-45s â•‘", protocol.c_str());
            ESP_LOGI("IR-DECODER", "â•‘  Raw Data: %-45s â•‘", resultToHexidecimal(&results).c_str());
            ESP_LOGI("IR-DECODER", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            
            // å°è¯•è§£æä¸ºACåè®®
            stdAc::state_t state;
            if (IRAc::isProtocolSupported(results.decode_type)) {
              if (IRAc::toCommon(&results, &state, nullptr)) {
                // è¾“å‡ºACå­—æ®µä¿¡æ¯
                ESP_LOGI("IR-DECODER", "â•‘  ğŸŒ¡ï¸  AC PROTOCOL FIELDS:                                â•‘");
                
                // ç”µæºçŠ¶æ€
                if (state.power != -1) {
                  ESP_LOGI("IR-DECODER", "â•‘    Power     : %-38s â•‘", state.power ? "ON" : "OFF");
                }
                
                // å·¥ä½œæ¨¡å¼
                if (state.mode != stdAc::opmode_t::kOff) {
                  const char* mode_str = "Unknown";
                  switch (state.mode) {
                    case stdAc::opmode_t::kAuto: mode_str = "Auto"; break;
                    case stdAc::opmode_t::kCool: mode_str = "Cool"; break;
                    case stdAc::opmode_t::kHeat: mode_str = "Heat"; break;
                    case stdAc::opmode_t::kDry: mode_str = "Dry"; break;
                    case stdAc::opmode_t::kFan: mode_str = "Fan"; break;
                  }
                  ESP_LOGI("IR-DECODER", "â•‘    Mode      : %-38s â•‘", mode_str);
                }
                
                // æ¸©åº¦
                if (state.degrees > 0) {
                  ESP_LOGI("IR-DECODER", "â•‘    Temp      : %.1fÂ°%-35s â•‘", 
                           state.degrees, state.celsius ? "C" : "F");
                }
                
                // é£é€Ÿ
                if (state.fanspeed != stdAc::fanspeed_t::kAuto) {
                  const char* fan_str = "Unknown";
                  switch (state.fanspeed) {
                    case stdAc::fanspeed_t::kMin: fan_str = "Min"; break;
                    case stdAc::fanspeed_t::kLow: fan_str = "Low"; break;
                    case stdAc::fanspeed_t::kMedium: fan_str = "Medium"; break;
                    case stdAc::fanspeed_t::kHigh: fan_str = "High"; break;
                    case stdAc::fanspeed_t::kMax: fan_str = "Max"; break;
                    case stdAc::fanspeed_t::kAuto: fan_str = "Auto"; break;
                  }
                  ESP_LOGI("IR-DECODER", "â•‘    Fan Speed : %-38s â•‘", fan_str);
                }
                
                // å‚ç›´æ‘†é£
                if (state.swingv != stdAc::swingv_t::kOff) {
                  const char* swing_str = "Unknown";
                  switch (state.swingv) {
                    case stdAc::swingv_t::kAuto: swing_str = "Auto"; break;
                    case stdAc::swingv_t::kHighest: swing_str = "Highest"; break;
                    case stdAc::swingv_t::kHigh: swing_str = "High"; break;
                    case stdAc::swingv_t::kMiddle: swing_str = "Middle"; break;
                    case stdAc::swingv_t::kLow: swing_str = "Low"; break;
                    case stdAc::swingv_t::kLowest: swing_str = "Lowest"; break;
                  }
                  ESP_LOGI("IR-DECODER", "â•‘    Swing V   : %-38s â•‘", swing_str);
                }
                
                // æ°´å¹³æ‘†é£
                if (state.swingh != stdAc::swingh_t::kOff) {
                  ESP_LOGI("IR-DECODER", "â•‘    Swing H   : %-38s â•‘", 
                           state.swingh == stdAc::swingh_t::kAuto ? "Auto" : "Manual");
                }
                
                // ç‰¹æ®Šæ¨¡å¼
                if (state.quiet) {
                  ESP_LOGI("IR-DECODER", "â•‘    Quiet     : %-38s â•‘", "ON");
                }
                if (state.turbo) {
                  ESP_LOGI("IR-DECODER", "â•‘    Turbo     : %-38s â•‘", "ON");
                }
                if (state.econo) {
                  ESP_LOGI("IR-DECODER", "â•‘    Econo     : %-38s â•‘", "ON");
                }
                if (state.light) {
                  ESP_LOGI("IR-DECODER", "â•‘    Light     : %-38s â•‘", "ON");
                }
                if (state.filter) {
                  ESP_LOGI("IR-DECODER", "â•‘    Filter    : %-38s â•‘", "ON");
                }
                if (state.clean) {
                  ESP_LOGI("IR-DECODER", "â•‘    Clean     : %-38s â•‘", "ON");
                }
                if (state.beep) {
                  ESP_LOGI("IR-DECODER", "â•‘    Beep      : %-38s â•‘", "ON");
                }
                if (state.sleep >= 0) {
                  ESP_LOGI("IR-DECODER", "â•‘    Sleep     : %-38d â•‘", state.sleep);
                }
              } else {
                ESP_LOGI("IR-DECODER", "â•‘  âš ï¸  AC protocol but failed to parse fields            â•‘");
              }
            } else {
              ESP_LOGI("IR-DECODER", "â•‘  â„¹ï¸  Non-AC protocol (TV/STB/etc)                      â•‘");
            }
            
            ESP_LOGI("IR-DECODER", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            
            // è¾“å‡ºåŸå§‹æ—¶åºæ•°æ®ï¼ˆç”¨äºæœªçŸ¥åè®®åˆ†æï¼‰
            if (results.decode_type == decode_type_t::UNKNOWN) {
              ESP_LOGI("IR-RAW", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
              ESP_LOGI("IR-RAW", "â•‘  UNKNOWN PROTOCOL - Raw Timing Data                      â•‘");
              ESP_LOGI("IR-RAW", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
              ESP_LOGI("IR-RAW", "â•‘  Samples: %-46d â•‘", results.rawlen);
              
              // è¾“å‡ºå‰40ä¸ªæ—¶åºå€¼
              for (uint16_t i = 1; i < results.rawlen && i < 40; i += 2) {
                if (i + 1 < results.rawlen) {
                  ESP_LOGI("IR-RAW", "â•‘  [%2d] Mark: %5d Âµs | Space: %5d Âµs                 â•‘", 
                           i/2, results.rawbuf[i] * kRawTick, results.rawbuf[i+1] * kRawTick);
                }
              }
              
              // åˆ†æå¼•å¯¼ç 
              if (results.rawlen > 2) {
                uint32_t mark = results.rawbuf[1] * kRawTick;
                uint32_t space = results.rawbuf[2] * kRawTick;
                ESP_LOGI("IR-RAW", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
                ESP_LOGI("IR-RAW", "â•‘  Leader Code: [%5d Âµs, %5d Âµs]                      â•‘", mark, space);
                
                // åè®®çŒœæµ‹
                if (mark > 8000 && mark < 10000 && space > 4000 && space < 5000) {
                  ESP_LOGI("IR-RAW", "â•‘  Hint: Possibly NEC/Gree/Midea-like protocol             â•‘");
                } else if (mark > 3000 && mark < 4000 && space > 1500 && space < 2000) {
                  ESP_LOGI("IR-RAW", "â•‘  Hint: Possibly Sony/Samsung-like protocol               â•‘");
                }
              }
              
              ESP_LOGI("IR-RAW", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
            }
            
            irrecv->resume();
          }

# IR receiver continuous monitoring (runs in background) + Statistics reporting
interval:
  - interval: 10ms
    then:
      - script.execute: ir_receiver_loop
  
  - interval: 30s
    then:
      - lambda: |-
          if (id(total_signals) > 0) {
            ESP_LOGI("STATS", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            ESP_LOGI("STATS", "â•‘          Protocol Statistics Report                      â•‘");
            ESP_LOGI("STATS", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            ESP_LOGI("STATS", "â•‘  Total Signals: %-41d â•‘", id(total_signals));
            ESP_LOGI("STATS", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            
            // æŒ‰è®¡æ•°æ’åºå¹¶æ˜¾ç¤ºTop 10
            std::vector<std::pair<std::string, int>> sorted_stats;
            for (auto& pair : id(protocol_stats)) {
              sorted_stats.push_back(pair);
            }
            std::sort(sorted_stats.begin(), sorted_stats.end(),
                      [](const auto& a, const auto& b) { return a.second > b.second; });
            
            int count = 0;
            for (auto& pair : sorted_stats) {
              if (count++ >= 10) break;
              ESP_LOGI("STATS", "â•‘  %-40s : %5d â•‘", pair.first.c_str(), pair.second);
            }
            
            ESP_LOGI("STATS", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          } else {
            ESP_LOGW("STATS", "âš ï¸  No IR signals received yet. Point remote at GPIO1 sensor!");
          }
