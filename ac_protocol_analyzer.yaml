esphome:
  name: ac-protocol-analyzer
  friendly_name: AC Protocol Analyzer with IRremoteESP8266
  comment: Universal A/C IR protocol analyzer supporting 50+ brands using IRremoteESP8266
  libraries:
    - "crankyoldgit/IRremoteESP8266@^2.8.6"
  on_boot:
    priority: -10
    then:
      - logger.log: 
          format: "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          level: INFO
      - logger.log:
          format: "ğŸš€ AC Protocol Analyzer Started (IRremoteESP8266)"
          level: INFO  
      - logger.log:
          format: "ğŸ“¡ IR RX: GPIO1 | Supports 50+ A/C Brands"
          level: INFO
      - logger.log:
          format: "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          level: INFO

esp32:
  board: m5stack-atoms3
  variant: esp32s3
  framework:
    type: arduino
    platform_version: 6.9.0

# æ—¥å¿—é…ç½® - USB CDCä¸²å£è¾“å‡º
logger:
  level: DEBUG
  hardware_uart: USB_CDC
  logs:
    component: ERROR
    sensor: INFO

# ç¦ç”¨WiFi - çº¯æœ¬åœ°è¿è¡Œ
wifi:
  manual_ip:
    static_ip: 192.168.1.99
    gateway: 192.168.1.1
    subnet: 255.255.255.0
  ssid: "dummy_ssid"
  password: "dummy12345"
  enable_on_boot: false

# å…¨å±€å˜é‡å­˜å‚¨ç»Ÿè®¡ä¿¡æ¯
globals:
  - id: total_signals_received
    type: int
    initial_value: '0'
  
  # åè®®ç»Ÿè®¡ï¼ˆä½¿ç”¨std::mapå­˜å‚¨åè®®åâ†’è®¡æ•°ï¼‰
  - id: protocol_stats
    type: std::map<std::string, int>
    restore_value: false

# è‡ªå®šä¹‰ç»„ä»¶ï¼šIRremoteESP8266æ¥æ”¶å™¨
custom_component:
  - lambda: |-
      #include <IRremoteESP8266.h>
      #include <IRrecv.h>
      #include <IRac.h>
      #include <IRutils.h>
      
      // å…¨å±€IRrecvå¯¹è±¡ï¼ˆ15KBç¼“å†²åŒºï¼‰
      static IRrecv* irrecv = nullptr;
      static IRAc ac(kGpioUnused);  // åªç”¨äºè§£æï¼Œä¸å‘é€
      
      // åˆå§‹åŒ–æ¥æ”¶å™¨
      auto setup_func = []() {
        const uint16_t kRecvPin = 1;  // GPIO1
        const uint16_t kCaptureBufferSize = 1024;  // 15KBç¼“å†²åŒº
        const uint8_t kTimeout = 50;  // 50msè¶…æ—¶
        const bool kUseModulation = true;
        
        irrecv = new IRrecv(kRecvPin, kCaptureBufferSize, kTimeout, kUseModulation);
        irrecv->enableIRIn();  // å¯åŠ¨æ¥æ”¶å™¨ï¼Œè‡ªåŠ¨å¯ç”¨æ‰€æœ‰åè®®
        
        ESP_LOGI("IRremoteESP8266", "âœ… Receiver initialized on GPIO1");
        ESP_LOGI("IRremoteESP8266", "ğŸ“Š Buffer: %d bytes | Timeout: %dms", kCaptureBufferSize, kTimeout);
        ESP_LOGI("IRremoteESP8266", "ğŸŒ All 50+ A/C protocols enabled for auto-detection");
      };
      
      // ä¸»å¾ªç¯ï¼šæ¥æ”¶å’Œè§£æIRä¿¡å·
      auto loop_func = []() {
        static decode_results results;
        
        if (irrecv->decode(&results)) {
          id(total_signals_received) += 1;
          
          // è·å–åè®®åç§°
          String protocol_name = typeToString(results.decode_type);
          
          // æ›´æ–°åè®®ç»Ÿè®¡
          std::string proto_str = protocol_name.c_str();
          id(protocol_stats)[proto_str]++;
          
          ESP_LOGI("IR-Detect", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
          ESP_LOGI("IR-Detect", "â•‘  Protocol: %-38s â•‘", protocol_name.c_str());
          ESP_LOGI("IR-Detect", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
          
          // è¾“å‡ºåŸå§‹åå…­è¿›åˆ¶æ•°æ®
          String hex_data = resultToHexidecimal(&results);
          ESP_LOGI("IR-Detect", "â•‘  Raw Data: %-38s â•‘", hex_data.c_str());
          ESP_LOGI("IR-Detect", "â•‘  Bits    : %-38d â•‘", results.bits);
          
          // å°è¯•è§£æä¸ºA/Cåè®®
          if (IRAc::isProtocolSupported(results.decode_type)) {
            stdAc::state_t state;
            if (IRAc::toCommon(&results, &state, nullptr)) {
              ESP_LOGI("IR-Detect", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
              ESP_LOGI("IR-Detect", "â•‘            A/C Protocol Fields                   â•‘");
              ESP_LOGI("IR-Detect", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
              
              // åªæ˜¾ç¤ºæœ‰æ„ä¹‰çš„å­—æ®µï¼ˆå€¼ä¸ä¸ºé»˜è®¤å€¼ï¼‰
              
              // ç”µæºçŠ¶æ€
              if (state.power) {
                ESP_LOGI("IR-Detect", "â•‘  Power   : %-38s â•‘", state.power ? "ON" : "OFF");
              }
              
              // å·¥ä½œæ¨¡å¼
              if (state.mode != stdAc::opmode_t::kOff) {
                const char* mode_str = "Unknown";
                switch (state.mode) {
                  case stdAc::opmode_t::kAuto: mode_str = "Auto"; break;
                  case stdAc::opmode_t::kCool: mode_str = "Cool (åˆ¶å†·)"; break;
                  case stdAc::opmode_t::kHeat: mode_str = "Heat (åˆ¶çƒ­)"; break;
                  case stdAc::opmode_t::kDry: mode_str = "Dry (é™¤æ¹¿)"; break;
                  case stdAc::opmode_t::kFan: mode_str = "Fan (é€é£)"; break;
                  default: break;
                }
                ESP_LOGI("IR-Detect", "â•‘  Mode    : %-38s â•‘", mode_str);
              }
              
              // æ¸©åº¦è®¾å®š
              if (state.degrees > 0 && state.degrees < 50) {
                ESP_LOGI("IR-Detect", "â•‘  Temp    : %.1fÂ°C                                  â•‘", state.degrees);
              }
              
              // é£é€Ÿ
              if (state.fanspeed != stdAc::fanspeed_t::kAuto) {
                const char* fan_str = "Unknown";
                switch (state.fanspeed) {
                  case stdAc::fanspeed_t::kMin: fan_str = "Min (æœ€ä½)"; break;
                  case stdAc::fanspeed_t::kLow: fan_str = "Low (ä½é€Ÿ)"; break;
                  case stdAc::fanspeed_t::kMedium: fan_str = "Medium (ä¸­é€Ÿ)"; break;
                  case stdAc::fanspeed_t::kHigh: fan_str = "High (é«˜é€Ÿ)"; break;
                  case stdAc::fanspeed_t::kMax: fan_str = "Max (æœ€é«˜)"; break;
                  case stdAc::fanspeed_t::kAuto: fan_str = "Auto (è‡ªåŠ¨)"; break;
                  default: break;
                }
                ESP_LOGI("IR-Detect", "â•‘  Fan     : %-38s â•‘", fan_str);
              }
              
              // å‚ç›´æ‘†é£
              if (state.swingv != stdAc::swingv_t::kOff) {
                const char* swing_str = "Unknown";
                switch (state.swingv) {
                  case stdAc::swingv_t::kAuto: swing_str = "Auto (è‡ªåŠ¨)"; break;
                  case stdAc::swingv_t::kHighest: swing_str = "Highest (æœ€é«˜)"; break;
                  case stdAc::swingv_t::kHigh: swing_str = "High (é«˜)"; break;
                  case stdAc::swingv_t::kMiddle: swing_str = "Middle (ä¸­)"; break;
                  case stdAc::swingv_t::kLow: swing_str = "Low (ä½)"; break;
                  case stdAc::swingv_t::kLowest: swing_str = "Lowest (æœ€ä½)"; break;
                  default: break;
                }
                ESP_LOGI("IR-Detect", "â•‘  V-Swing : %-38s â•‘", swing_str);
              }
              
              // æ°´å¹³æ‘†é£
              if (state.swingh != stdAc::swingh_t::kOff) {
                const char* swingh_str = "Unknown";
                switch (state.swingh) {
                  case stdAc::swingh_t::kAuto: swingh_str = "Auto (è‡ªåŠ¨)"; break;
                  case stdAc::swingh_t::kLeftMax: swingh_str = "Left Max (æœ€å·¦)"; break;
                  case stdAc::swingh_t::kLeft: swingh_str = "Left (å·¦)"; break;
                  case stdAc::swingh_t::kMiddle: swingh_str = "Middle (ä¸­)"; break;
                  case stdAc::swingh_t::kRight: swingh_str = "Right (å³)"; break;
                  case stdAc::swingh_t::kRightMax: swingh_str = "Right Max (æœ€å³)"; break;
                  default: break;
                }
                ESP_LOGI("IR-Detect", "â•‘  H-Swing : %-38s â•‘", swingh_str);
              }
              
              // ç‰¹æ®ŠåŠŸèƒ½
              if (state.quiet) {
                ESP_LOGI("IR-Detect", "â•‘  Quiet   : Enabled (é™éŸ³)                        â•‘");
              }
              if (state.turbo) {
                ESP_LOGI("IR-Detect", "â•‘  Turbo   : Enabled (å¼ºåŠ›)                        â•‘");
              }
              if (state.econo) {
                ESP_LOGI("IR-Detect", "â•‘  Econo   : Enabled (èŠ‚èƒ½)                        â•‘");
              }
              if (state.light) {
                ESP_LOGI("IR-Detect", "â•‘  Light   : Enabled (æ˜¾ç¤ºç¯)                      â•‘");
              }
              if (state.filter) {
                ESP_LOGI("IR-Detect", "â•‘  Filter  : Enabled (è¿‡æ»¤å™¨)                      â•‘");
              }
              if (state.clean) {
                ESP_LOGI("IR-Detect", "â•‘  Clean   : Enabled (æ¸…æ´)                        â•‘");
              }
              if (state.beep) {
                ESP_LOGI("IR-Detect", "â•‘  Beep    : Enabled (èœ‚é¸£)                        â•‘");
              }
              
              // ç¡çœ æ¨¡å¼
              if (state.sleep >= 0) {
                ESP_LOGI("IR-Detect", "â•‘  Sleep   : %d minutes                             â•‘", state.sleep);
              }
            } else {
              ESP_LOGI("IR-Detect", "â•‘  âš ï¸  A/C protocol detected but failed to parse   â•‘");
            }
          } else {
            // éA/Cåè®®ï¼Œè¾“å‡ºåŸå§‹æ—¶åºæ•°æ®
            ESP_LOGI("IR-Detect", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            ESP_LOGI("IR-Detect", "â•‘  â„¹ï¸  Non-A/C Protocol - Raw Timing Data         â•‘");
            ESP_LOGI("IR-Detect", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            
            String timing_data = resultToTimingInfo(&results);
            // åˆ†è¡Œæ˜¾ç¤ºtimingæ•°æ®ï¼ˆæ¯è¡Œæœ€å¤š48å­—ç¬¦ï¼‰
            int start = 0;
            while (start < timing_data.length()) {
              String line = timing_data.substring(start, start + 48);
              ESP_LOGI("IR-Detect", "â•‘  %-48s â•‘", line.c_str());
              start += 48;
            }
          }
          
          ESP_LOGI("IR-Detect", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          
          // å‡†å¤‡æ¥æ”¶ä¸‹ä¸€ä¸ªä¿¡å·
          irrecv->resume();
        }
      };
      
      // æ³¨å†Œåˆ°ESPHome
      App.register_component(new Component());
      App.setup_priority_init.push_back(setup_func);
      App.loop_late.push_back(loop_func);
      
      return {};

# å®šæ—¶ç»Ÿè®¡æŠ¥å‘Š
interval:
  # æ¯30ç§’è¾“å‡ºåè®®ç»Ÿè®¡ä¿¡æ¯
  - interval: 30s
    then:
      - lambda: |-
          if (id(total_signals_received) > 0) {
            ESP_LOGI("STATS", "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
            ESP_LOGI("STATS", "â•‘          Protocol Statistics Report                â•‘");
            ESP_LOGI("STATS", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            ESP_LOGI("STATS", "â•‘  Total Signals Received: %-25d â•‘", id(total_signals_received));
            ESP_LOGI("STATS", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            
            // å°†mapè½¬æ¢ä¸ºvectorä»¥ä¾¿æ’åº
            std::vector<std::pair<std::string, int>> stats_vec;
            for (const auto& pair : id(protocol_stats)) {
              stats_vec.push_back(pair);
            }
            
            // æŒ‰è®¡æ•°é™åºæ’åº
            std::sort(stats_vec.begin(), stats_vec.end(),
                     [](const auto& a, const auto& b) { return a.second > b.second; });
            
            // è¾“å‡ºTop 10åè®®
            ESP_LOGI("STATS", "â•‘  Protocol Name                    â”‚    Count       â•‘");
            ESP_LOGI("STATS", "â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•ªâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
            
            int display_count = std::min(10, (int)stats_vec.size());
            for (int i = 0; i < display_count; i++) {
              ESP_LOGI("STATS", "â•‘  %-33s â”‚ %14d â•‘", 
                      stats_vec[i].first.c_str(), stats_vec[i].second);
            }
            
            if (stats_vec.size() > 10) {
              ESP_LOGI("STATS", "â•‘  ... and %d more protocols                         â•‘", 
                      (int)stats_vec.size() - 10);
            }
            
            ESP_LOGI("STATS", "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
          } else {
            ESP_LOGW("STATS", "âš ï¸  No IR signals received yet. Check hardware connection!");
          }

# ç”¨æˆ·æŒ‰é’®ç”¨äºæ¸…é™¤ç»Ÿè®¡ï¼ˆGPIO41ï¼‰
binary_sensor:
  - platform: gpio
    pin:
      number: GPIO41
      mode:
        input: true
        pullup: true
      inverted: true
    name: "User Button"
    internal: true
    on_press:
      then:
        - lambda: |-
            ESP_LOGI("BUTTON", "ğŸ”˜ Button pressed - clearing statistics...");
            id(total_signals_received) = 0;
            id(protocol_stats).clear();
            ESP_LOGI("BUTTON", "âœ… Statistics cleared");
